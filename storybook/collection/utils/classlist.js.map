{"version":3,"file":"classlist.js","sourceRoot":"","sources":["../../src/utils/classlist.ts"],"names":[],"mappings":"AAAA,OAAO,EAAc,IAAI,EAAE,MAAM,MAAM,CAAC;AAexC;;;GAGG;AACH,MAAM,UAAU,SAAS,CACrB,IAAgB,EAChB,MAAsB;IAEtB,OAAO,UAAU,KAA2B;QACxC,MAAM,EACF,QAAQ,GAAG,EAAE,EACb,eAAe,GAAG,EAAE,EACpB,gBAAgB,GAAG,EAAE,GACxB,GAAG,MAAM,IAAI,EAAE,CAAC;QACjB,MAAM,iBAAiB,GAAa,EAAE,CAAC;QAEvC,mBAAmB;QACnB,IAAI,KAAK,IAAI,QAAQ,EAAE,CAAC;YACpB,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,EAAE;gBACpD,MAAM,eAAe,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC;gBAC1C,IAAI,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,eAAe,CAAC,EAAE,CAAC;oBACxC,iBAAiB,CAAC,IAAI,CAClB,QAAQ,CAAC,QAAQ,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,CAC5C,CAAC;gBACN,CAAC;YACL,CAAC,CAAC,CAAC;QACP,CAAC;QAED,2BAA2B;QAC3B,IAAI,eAAe,IAAI,QAAQ,EAAE,CAAC;YAC9B,MAAM,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,OAAO,CACnC,CAAC,CAAC,WAAW,EAAE,YAAY,CAAC,EAAE,EAAE;gBAC5B,IAAI,KAAK,IAAI,OAAO,KAAK,CAAC,WAAW,CAAC,KAAK,WAAW,EAAE,CAAC;oBACrD,OAAO,CAAC,wCAAwC;gBACpD,CAAC;gBAED,MAAM,kBAAkB,GAAG,MAAM,CAAC,YAAY,CAAC,CAAC;gBAChD,IAAI,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC,kBAAkB,CAAC,EAAE,CAAC;oBAC9C,iBAAiB,CAAC,IAAI,CAClB,QAAQ,CAAC,WAAW,CAAC,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAClD,CAAC;gBACN,CAAC;YACL,CAAC,CACJ,CAAC;QACN,CAAC;QAED,4BAA4B;QAC5B,IAAI,gBAAgB,EAAE,CAAC;YACnB,gBAAgB,CAAC,OAAO,CAAC,CAAC,eAAe,EAAE,EAAE;gBACzC,MAAM,EACF,KAAK,EAAE,aAAa,EACpB,SAAS,EAAE,iBAAiB,EAC5B,GAAG,UAAU,EAChB,GAAG,eAAe,CAAC;gBACpB,MAAM,gBAAgB,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,KAAK,CACrD,CAAC,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,EAAE;oBACtB,OAAO,CACH,KAAK;wBACL,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,KAAK,MAAM,CAAC,SAAS,CAAC,CAChD,CAAC;gBACN,CAAC,CACJ,CAAC;gBAEF,IAAI,gBAAgB,EAAE,CAAC;oBACnB,MAAM,kBAAkB,GACpB,aAAa,IAAI,iBAAiB,IAAI,EAAE,CAAC;oBAC7C,IAAI,kBAAkB,EAAE,CAAC;wBACrB,iBAAiB,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;oBAC/C,CAAC;gBACL,CAAC;YACL,CAAC,CAAC,CAAC;QACP,CAAC;QAED,OAAO,EAAE,CAAC,IAAI,EAAE,GAAG,iBAAiB,CAAC,CAAC;IAC1C,CAAC,CAAC;AACN,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,EAAE,CAAC,GAAG,MAAoB;IACtC,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;AACxB,CAAC","sourcesContent":["import { ClassValue, clsx } from 'clsx';\n\ntype VariantValue = string | number | boolean;\ntype ClassProp = string | undefined | null;\ntype VariantProps = Record<string, VariantValue>;\ntype VariantConfig = Record<string, Record<string, ClassProp>>;\n\ntype CVAProperties = {\n    variants?: VariantConfig;\n    defaultVariants?: VariantProps;\n    compoundVariants?: Array<\n        Record<string, any> & { class?: string; className?: string }\n    >;\n};\n\n/**\n * A utility function for creating conditional class names similar to class-variance-authority\n * but implemented locally to avoid dependency issues.\n */\nexport function classlist(\n    base: ClassValue,\n    config?: CVAProperties,\n): (props?: Record<string, any>) => string {\n    return function (props?: Record<string, any>): string {\n        const {\n            variants = {},\n            defaultVariants = {},\n            compoundVariants = [],\n        } = config || {};\n        const variantClassNames: string[] = [];\n\n        // Process variants\n        if (props && variants) {\n            Object.entries(props).forEach(([propName, propValue]) => {\n                const stringPropValue = String(propValue);\n                if (variants[propName]?.[stringPropValue]) {\n                    variantClassNames.push(\n                        variants[propName][stringPropValue] || '',\n                    );\n                }\n            });\n        }\n\n        // Process default variants\n        if (defaultVariants && variants) {\n            Object.entries(defaultVariants).forEach(\n                ([variantName, variantValue]) => {\n                    if (props && typeof props[variantName] !== 'undefined') {\n                        return; // Skip if variant is specified in props\n                    }\n\n                    const stringVariantValue = String(variantValue);\n                    if (variants[variantName]?.[stringVariantValue]) {\n                        variantClassNames.push(\n                            variants[variantName][stringVariantValue] || '',\n                        );\n                    }\n                },\n            );\n        }\n\n        // Process compound variants\n        if (compoundVariants) {\n            compoundVariants.forEach((compoundVariant) => {\n                const {\n                    class: compoundClass,\n                    className: compoundClassName,\n                    ...conditions\n                } = compoundVariant;\n                const allConditionsMet = Object.entries(conditions).every(\n                    ([condName, condValue]) => {\n                        return (\n                            props &&\n                            String(props[condName]) === String(condValue)\n                        );\n                    },\n                );\n\n                if (allConditionsMet) {\n                    const compoundClassToUse =\n                        compoundClass || compoundClassName || '';\n                    if (compoundClassToUse) {\n                        variantClassNames.push(compoundClassToUse);\n                    }\n                }\n            });\n        }\n\n        return cn(base, ...variantClassNames);\n    };\n}\n\n/**\n * Combines class names with clsx\n */\nexport function cn(...inputs: ClassValue[]): string {\n    return clsx(inputs);\n}\n"]}