{"version":3,"names":["TOKEN_TEXT_DARK","heightVariants","xs","sm","md","lg","xl","auto","AtuiChartDonut","constructor","hostRef","this","height","legend_format","labels","boxWidth","boxHeight","fontSize","onHover","event","native","target","style","cursor","display","tooltip_options","mode","intersect","position","color_palette","ChartColorPalette","CATEGORICAL","cutout","defaultPieTooltipOptions","animation","duration","getConfig","config","getDrawCenterTextPlugin","id","afterDatasetDraw","chart","centerX","chartArea","left","right","centerY","top","bottom","ctx","restore","textFontSize","toFixed","valueFontSize","fillStyle","textAlign","textBaseline","font","addText","text","x","y","textMetrics","measureText","textHeight","actualBoundingBoxAscent","actualBoundingBoxDescent","fillText","center_value","center_text","save","initChart","Chart","register","DoughnutController","ArcElement","Legend","Tooltip","Filler","colors","getChartColors","applyPresetPalette","plugins","push","type","data","Object","assign","datasets","map","dataset","options","animations","maintainAspectRatio","aspectRatio","layout","padding","legend","tooltip","canvasEl","width","CUSTOM","color","_","index","length","backgroundColor","hoverBackgroundColor","borderColor","hoverBorderColor","componentDidUpdate","componentDidLoad","render","h","Host","key","role","class","ref","el","transform","maxWidth","maxHeight"],"sources":["src/components/atui-chart-donut/atui-chart-donut.tsx"],"sourcesContent":["import { Component, h, Host, Method, Prop } from '@stencil/core';\nimport {\n    ArcElement,\n    Chart,\n    ChartConfiguration,\n    ChartDataset,\n    DoughnutController,\n    Filler,\n    Legend,\n    Tooltip,\n    Plugin,\n} from 'chart.js';\nimport 'chartjs-adapter-moment';\nimport { ChartColorPalette } from '../../types/chart-color';\nimport { getChartColors } from '../../utils/chart-color';\nconst TOKEN_TEXT_DARK = '#0f172a';\n\nexport type Height = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | 'auto';\nexport type LegendPosition = 'top' | 'bottom' | 'left' | 'right';\n\nconst heightVariants = {\n    xs: 'h-[70px]',\n    sm: 'h-[160px]',\n    md: 'h-[235px]',\n    lg: 'h-[330px]',\n    xl: 'h-[440px]',\n    auto: 'h-full',\n};\n\n/**\n * @category Data Visualization\n * @description A donut chart component for visualizing proportional data with customizable colors and legends. Built on Chart.js with responsive design and interactive hover effects.\n */\n@Component({\n    tag: 'atui-chart-donut',\n    shadow: false,\n})\nexport class AtuiChartDonut {\n    /**\n     * Data to be shown in the chart. ChartDataset properties can be found\n     * [here](https://www.chartjs.org/docs/latest/charts/doughnut.html#dataset-properties)\n     */\n    @Prop()\n    data: {\n        labels: string[];\n        datasets: ChartDataset[];\n    };\n\n    /**\n     * Additional options to be added to the chart configuration\n     */\n    @Prop()\n    options?: object;\n\n    /**\n     * Height of the chart\n     */\n    @Prop()\n    height?: Height = 'md';\n\n    /**\n     * Additional options for formatting the legend\n     */\n    @Prop()\n    legend_format?: object = {\n        labels: {\n            boxWidth: 10,\n            boxHeight: 10,\n            fontSize: 11,\n        },\n        onHover: (event): void => {\n            if (event.native) {\n                (event.native.target as HTMLElement).style.cursor = 'pointer';\n            }\n        },\n        display: true,\n    };\n\n    /**\n     * Additional options for the tooltip\n     */\n    @Prop()\n    tooltip_options?: object = {\n        mode: 'index',\n        intersect: false,\n        position: 'nearest',\n    };\n\n    /**\n     * Additional plugin options\n     */\n    @Prop()\n    plugins?: Plugin[];\n\n    /**\n     * Animations added to the chart configuration\n     */\n    @Prop()\n    animations: object;\n\n    /**\n     * Colour palette to use for the chart. Preset options are provided ChartColourPalette:\n     * 'categorical' : For charts with data that have distinct labels and no natural order\n     * 'sequential' : For charts with data that is numeric or is naturally ordered.\n     * 'alert' : For charts that relate to health state. Note that data requires a specific order.\n     * 'custom' : Use colors defined in data. If none are provided, the ChartJS default will be used.\n     */\n    @Prop()\n    color_palette: ChartColorPalette = ChartColorPalette.CATEGORICAL;\n\n    /**\n     * Optional value text to display in the center of the donut chart\n     */\n    @Prop()\n    center_value?: string;\n\n    /**\n     * Optional heading text to display in the center of the donut chart\n     */\n    @Prop()\n    center_text?: string;\n\n    /**\n     * Controls the thickness of the donut ring. Value between 0 and 100.\n     * 0 means no cutout (solid circle), 100 means maximum cutout (thin ring).\n     * Default is 70.\n     */\n    @Prop()\n    cutout?: number = 70;\n\n    canvasEl: HTMLCanvasElement;\n    config: ChartConfiguration;\n\n    /**\n     * Getter method for the chart's configuration object\n     * @returns Configuration of the chart\n     */\n    @Method()\n    async getConfig(): Promise<object> {\n        return this.config;\n    }\n\n    defaultPieTooltipOptions = {\n        mode: 'index',\n        intersect: true,\n        position: 'nearest',\n        animation: {\n            duration: 150,\n        },\n    };\n\n    private getDrawCenterTextPlugin(): Plugin {\n        return {\n            id: 'DrawCenterTextPlugin',\n            afterDatasetDraw: (chart): void => {\n                const centerX =\n                    (chart.chartArea.left + chart.chartArea.right) / 2;\n                const centerY =\n                    (chart.chartArea.top + chart.chartArea.bottom) / 2;\n                const ctx = chart.ctx;\n                if (!ctx) {\n                    return;\n                }\n\n                ctx.restore();\n\n                const height = chart.chartArea.bottom - chart.chartArea.top;\n                const textFontSize =\n                    (height / 250).toFixed(2) + 'em sans-serif';\n                const valueFontSize =\n                    (height / 180).toFixed(2) + 'em sans-serif';\n\n                ctx.fillStyle = TOKEN_TEXT_DARK;\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.font = '500 ' + valueFontSize;\n\n                const addText = (\n                    fontSize: string,\n                    text: string,\n                    x: number,\n                    y: number,\n                    position: 'top' | 'middle' | 'bottom',\n                ): void => {\n                    ctx.font = '500 ' + fontSize;\n                    const textMetrics = ctx.measureText(text);\n                    const textHeight =\n                        textMetrics.actualBoundingBoxAscent +\n                        textMetrics.actualBoundingBoxDescent;\n\n                    if (position != 'middle') {\n                        y =\n                            position === 'top'\n                                ? y - textHeight\n                                : y + textHeight;\n                    }\n                    ctx.fillText(text, x, y);\n                };\n\n                if (this.center_value) {\n                    addText(\n                        valueFontSize,\n                        this.center_value,\n                        centerX,\n                        centerY,\n                        'top',\n                    );\n                    addText(\n                        textFontSize,\n                        this.center_text,\n                        centerX,\n                        centerY,\n                        'bottom',\n                    );\n                } else if (this.center_text) {\n                    addText(\n                        textFontSize,\n                        this.center_text,\n                        centerX,\n                        centerY,\n                        'middle',\n                    );\n                }\n\n                ctx.save();\n            },\n        };\n    }\n\n    initChart() {\n        Chart.register(DoughnutController, ArcElement, Legend, Tooltip, Filler);\n\n        const colors = getChartColors(this.color_palette);\n\n        if (colors) {\n            this.applyPresetPalette(colors);\n        }\n\n        const plugins = this.plugins ? [...this.plugins] : [];\n\n        if (this.center_text || this.center_value) {\n            plugins.push(this.getDrawCenterTextPlugin());\n        }\n\n        this.config = {\n            type: 'doughnut',\n            data: {\n                ...this.data,\n                datasets: this.data.datasets.map((dataset) => ({\n                    ...dataset,\n                    cutout: `${this.cutout}%`,\n                })),\n            },\n            options: {\n                animation: this.animations,\n                ...this.options,\n                maintainAspectRatio: true,\n                aspectRatio: 1,\n                layout: {\n                    padding: 16,\n                },\n                plugins: {\n                    legend: this.legend_format,\n                    tooltip:\n                        this.tooltip_options || this.defaultPieTooltipOptions,\n                },\n            },\n            plugins: plugins,\n        };\n\n        new Chart(this.canvasEl, this.config as ChartConfiguration);\n        this.canvasEl.style.width = '100%';\n        this.canvasEl.style.height = '100%';\n    }\n\n    applyPresetPalette(colors: string[]): void {\n        if (this.color_palette === ChartColorPalette.CUSTOM) {\n            return;\n        }\n\n        this.data.datasets = this.data.datasets.map((dataset) => {\n            const color = dataset.data.map(\n                (_, index) => colors[index % colors.length],\n            );\n\n            return {\n                ...dataset,\n                backgroundColor: color,\n                hoverBackgroundColor: color,\n                borderColor: color,\n                hoverBorderColor: color,\n            };\n        });\n    }\n\n    componentDidUpdate() {\n        if (this.data && this.data.datasets.length) {\n            this.initChart();\n        }\n    }\n\n    /**\n     * componentDidLoad will be run, but if the props haven't been passed to it yet,\n     * it will throw an error. So we catch this, and wait for the props to be passed\n     * to the component where it will run componentDidUpdtae.\n     */\n    componentDidLoad() {\n        if (this.data && this.data.datasets.length) {\n            this.initChart();\n        }\n    }\n\n    render() {\n        return (\n            <Host\n                role=\"region\"\n                class={`relative flex w-full flex-col items-center justify-center ${heightVariants[this.height]}`}\n            >\n                <canvas\n                    ref={(el) => (this.canvasEl = el)}\n                    style={{\n                        position: 'absolute',\n                        top: '50%',\n                        left: '50%',\n                        transform: 'translate(-50%, -50%)',\n                        maxWidth: '100%',\n                        maxHeight: '100%',\n                    }}\n                />\n            </Host>\n        );\n    }\n}\n"],"mappings":"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","ignoreList":[]}