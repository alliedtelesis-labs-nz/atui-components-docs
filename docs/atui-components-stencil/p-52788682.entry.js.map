{"version":3,"names":["heightVariants","xs","sm","md","lg","xl","auto","AtuiChartBarLine","constructor","hostRef","this","height","color_palette","ChartColorPalette","CATEGORICAL","formatThresholds","thresholds","datasets","forEach","threshold","push","type","label","borderColor","color","borderCapStyle","backgroundColor","fill","data","pointRadius","borderDash","dashLine","undefined","tension","stepped","order","getConfig","config","initChart","Chart","register","LinearScale","BarController","CategoryScale","BarElement","TimeScale","LineController","LineElement","PointElement","Colors","Legend","Tooltip","Filler","colors","getChartColors","applyPresetPalette","point_styles","pointStylesSetup","labels","options","Object","assign","devicePixelRatio","maintainAspectRatio","scales","y","y_axis_format","beginAtZero","min","x","x_axis_format","time","displayFormats","day","minute","hour","ticks","font","size","autoSkip","align","maxRotation","minRotation","plugins","tooltip","tooltip_options","mode","intersect","position","animation","duration","legend","legend_format","boxWidth","boxHeight","fontSize","borderRadius","onHover","event","native","target","style","cursor","display","clip","elements","line","borderWidth","time_range","dates","getMinMaxDateStrings","max","canvasEl","width","componentDidUpdate","length","componentDidLoad","map","dataset","CUSTOM","index","timeRange","timeWithUnit","selected","custom","TimeDateUtil","getAbsoluteDateRange","startDate","endDate","getDateRange","toString","render","h","Host","key","class","ref","el"],"sources":["src/components/atui-chart-bar-line/atui-chart-bar-line.tsx"],"sourcesContent":["import { Component, h, Host, Method, Prop } from '@stencil/core';\nimport {\n    BarController,\n    BarElement,\n    CategoryScale,\n    Chart,\n    LinearScale,\n    LineController,\n    LineElement,\n    TimeScale,\n    Legend,\n    Tooltip,\n    PointElement,\n    Filler,\n    ChartConfiguration,\n    PointStyle,\n    Colors,\n    ChartDataset,\n    Point,\n    BubbleDataPoint,\n    Color,\n} from 'chart.js';\nimport 'chartjs-adapter-moment';\nimport { SelectedTimeRange, TimeWithUnit } from '../../types';\nimport { TimeDateUtil } from '../../utils/time-date.util';\nimport { SelectedTimeRangeExtended } from '../../components';\nimport { Height } from '../atui-chart-donut/atui-chart-donut';\nimport { ChartColorPalette } from '../../types/chart-color';\nimport { getChartColors } from '../../utils/chart-color';\n\n/*\n * NOTES:\n *\n * The exported class contains a function from chart.js called useOffsetPos.\n * This isn't allowed by react (because it starts with the word 'use'), so the\n * build script runs\n *\n *  sed -i 's/useOffsetPos/offsetPos/g' dist/components/atui-chart-bar-line.js\n *\n * to replace all occurences of useOffsetPos with offsetPos.\n */\nexport interface PointStyles {\n    pointBackgroundColor: Color;\n    pointBorderColor: Color;\n    pointBorderWidth: number;\n    pointHitRadius: number;\n    pointHoverBackgroundColor: Color;\n    pointHoverBorderColor: Color;\n    pointHoverBorderWidth: number;\n    pointHoverRadius: number;\n    pointRadius: number;\n    pointRotaion: number;\n    pointStyle: PointStyle;\n}\n\nexport interface Threshold {\n    label: string;\n    data: (number | Point | [number, number] | BubbleDataPoint)[];\n    color?: string;\n    dashLine?: boolean;\n    stepped?: boolean;\n}\n\nconst heightVariants = {\n    xs: 'h-[70px]',\n    sm: 'h-[160px]',\n    md: 'h-[235px]',\n    lg: 'h-[330px]',\n    xl: 'h-[440px]',\n    auto: 'h-full',\n};\n\n/**\n * @category Data Visualization\n * @description A flexible chart component for displaying bar and line charts with extensive customization options. Supports multiple data series, thresholds, time-based data, and various color palettes.\n */\n/**\n * ### ```interface PointStyles```\n * ```\n *  pointBackgroundColor: Color;\n *  pointBorderColor: Color;\n *  pointBorderWidth: number;\n *  pointHitRadius: number;\n *  pointHoverBackgroundColor: Color;\n *  pointHoverBorderColor: Color;\n *  pointHoverBorderWidth: number;\n *  pointHoverRadius: number;\n *  pointRadius: number;\n *  pointRotaion: number;\n *  pointStyle: PointStyle;\n * ```\n * ### ```interface Threshold```\n * ```\n *  label: string;\n *  data: (number | Point | [number, number] | BubbleDataPoint)[];\n *  color?: string;\n *  dashLine?: boolean;\n *  stepped?: boolean;\n * ```\n */\n@Component({\n    tag: 'atui-chart-bar-line',\n    shadow: false,\n})\nexport class AtuiChartBarLine {\n    /**\n     * Type of the chart\n     */\n    @Prop()\n    type: 'bar' | 'line';\n\n    /**\n     * Data to go in the chart. ChartDataset properties found\n     * [here for line](https://www.chartjs.org/docs/latest/charts/line.html),\n     * and [here for bar](https://www.chartjs.org/docs/latest/charts/bar.html)\n     */\n    @Prop({ mutable: true })\n    data: {\n        labels: string[];\n        datasets: ChartDataset[];\n    };\n\n    /**\n     * X axis formatting to be applied to the chart.\n     * If you would like the default formatting provided by chart.js, set this to an empty object.\n     */\n    @Prop()\n    x_axis_format: object;\n\n    /**\n     * Y axis formatting to be applied to the chart.\n     */\n    @Prop()\n    y_axis_format?: object;\n\n    /**\n     * Additional options to go into the 'options' seciont of the chart configuration\n     */\n    @Prop()\n    options?: object;\n\n    /**\n     * Options for the tooltips on the chart\n     */\n    @Prop()\n    tooltip_options?: object;\n\n    /**\n     * Options for the legend\n     */\n    @Prop()\n    legend_format?: object;\n\n    /**\n     * Thresholds to be displayed in the chart\n     */\n    @Prop()\n    thresholds?: Threshold[];\n\n    /**\n     * Styles for the points in the chart\n     */\n    @Prop()\n    point_styles?: PointStyles;\n\n    /**\n     * The time range that the chart is displayed in.\n     */\n    @Prop()\n    time_range?: SelectedTimeRangeExtended;\n\n    /**\n     * Height of the chart.\n     */\n    @Prop()\n    height?: Height = 'md';\n    canvasEl: HTMLCanvasElement;\n    config: ChartConfiguration;\n\n    /**\n     * Colour palette to use for the chart. Preset options are provided ChartColourPalette:\n     * 'categorical' : For charts with data that have distinct labels and no natural order\n     * 'sequential' : For charts with data that is numeric or is naturally ordered.\n     * 'alert' : For charts that relate to health state. Note that data requires a specific order.\n     * 'custom' : Use colors defined in data. If none are provided, the ChartJS default will be used.\n     */\n    @Prop()\n    color_palette: ChartColorPalette = ChartColorPalette.CATEGORICAL;\n\n    /**\n     * Getter method for the chart's configuration object\n     * @returns Configuration of the chart\n     */\n    @Method()\n    async getConfig(): Promise<object> {\n        return this.config;\n    }\n\n    initChart() {\n        Chart.register(\n            LinearScale,\n            BarController,\n            CategoryScale,\n            BarElement,\n            TimeScale,\n            LineController,\n            LineElement,\n            PointElement,\n            Colors,\n            Legend,\n            Tooltip,\n            Filler,\n        );\n\n        const colors = getChartColors(this.color_palette);\n\n        if (colors) {\n            this.applyPresetPalette(colors);\n        }\n\n        if (this.point_styles) {\n            this.pointStylesSetup();\n        }\n\n        this.config = {\n            type: this.type,\n            data: {\n                labels: this.data.labels,\n                datasets: [...this.data.datasets, ...this.formatThresholds()],\n            },\n            options: {\n                devicePixelRatio: 2,\n                maintainAspectRatio: false,\n                scales: {\n                    y: this.y_axis_format || {\n                        beginAtZero: true,\n                        type: 'linear',\n                        min: 0,\n                    },\n                    x: this.x_axis_format || {\n                        type: 'time',\n                        time: {\n                            displayFormats: {\n                                day: 'ddd',\n                                minute: 'MMM D H:mm',\n                                hour: 'MMM D H:mm',\n                            },\n                        },\n                        ticks: {\n                            font: {\n                                size: 11,\n                            },\n                            autoSkip: true,\n                            align: 'center',\n                            maxRotation: 0,\n                            minRotation: 0,\n                        },\n                    },\n                },\n                ...this.options,\n                plugins: {\n                    tooltip: this.tooltip_options || {\n                        mode: 'index',\n                        intersect: false,\n                        position: 'nearest',\n                        animation: {\n                            duration: 150,\n                        },\n                    },\n                    legend: this.legend_format || {\n                        labels: {\n                            boxWidth: 8,\n                            boxHeight: 8,\n                            fontSize: 10,\n                            borderRadius: 2,\n                        },\n                        onHover: (event): void => {\n                            if (event.native) {\n                                (\n                                    event.native.target as HTMLElement\n                                ).style.cursor = 'pointer';\n                            }\n                        },\n                        display: true,\n                    },\n                },\n                clip: false,\n                elements: {\n                    line: {\n                        tension: 0,\n                        borderWidth: 2,\n                    },\n                },\n            },\n        };\n\n        if (this.time_range) {\n            const dates = this.getMinMaxDateStrings(this.time_range);\n            this.config.options.scales.x['min'] = dates.min;\n            this.config.options.scales.x['max'] = dates.max;\n        }\n\n        new Chart(this.canvasEl, this.config);\n        this.canvasEl.style.width = '';\n        this.canvasEl.style.height = '';\n    }\n\n    componentDidUpdate() {\n        if (this.data && this.data.datasets.length) {\n            this.initChart();\n        }\n    }\n\n    /**\n     * componentDidLoad will be run, but if the props haven't been passed to it yet,\n     * it will throw an error. So we catch this, and wait for the props to be passed\n     * to the component where it will run componentDidUpdtae.\n     */\n    componentDidLoad() {\n        if (this.data && this.data.datasets.length) {\n            this.initChart();\n        }\n    }\n\n    pointStylesSetup(): void {\n        this.data.datasets = this.data.datasets.map((dataset) => {\n            return {\n                ...dataset,\n                ...(this.point_styles as object),\n            };\n        });\n    }\n\n    applyPresetPalette(colors: string[]): void {\n        if (this.color_palette === ChartColorPalette.CUSTOM) {\n            return;\n        }\n\n        this.data.datasets = this.data.datasets.map((dataset, index) => {\n            const color = colors[index % colors.length];\n            return {\n                ...dataset,\n                backgroundColor: color,\n                borderColor: color,\n            };\n        });\n    }\n\n    getMinMaxDateStrings(timeRange: SelectedTimeRange): {\n        min: string;\n        max: string;\n    } {\n        const timeWithUnit = timeRange.selected as TimeWithUnit;\n        const custom = timeRange.custom\n            ? TimeDateUtil.getAbsoluteDateRange(timeRange.custom)\n            : null;\n        const { startDate, endDate } = TimeDateUtil.getDateRange(\n            custom,\n            timeWithUnit,\n            null,\n        );\n        return { min: startDate.toString(), max: endDate.toString() };\n    }\n\n    formatThresholds = () => {\n        if (!this.thresholds) {\n            return [];\n        }\n        const datasets: ChartDataset[] = [];\n        this.thresholds.forEach((threshold) => {\n            datasets.push({\n                type: 'line',\n                label: threshold.label,\n                borderColor: threshold.color,\n                borderCapStyle: 'butt',\n                backgroundColor: 'white',\n                fill: false,\n                data: threshold.data,\n                pointRadius: 0,\n                borderDash: threshold.dashLine ? [6, 3] : undefined,\n                tension: 0,\n                stepped: threshold.stepped,\n                order: 1,\n            });\n        });\n        return datasets;\n    };\n\n    render() {\n        return (\n            <Host style={{ height: '100%', width: '100%' }}>\n                <section class={`min-w-100 ${heightVariants[this.height]}`}>\n                    <canvas ref={(el) => (this.canvasEl = el)} />\n                </section>\n            </Host>\n        );\n    }\n}\n"],"mappings":"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","ignoreList":[]}